{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dweeter","text":"<p>Documentation</p> <p>Encrypted messaging through the free dweet service. Dweet is a simple machine-to-machine (M2M) service from dweet.io.</p> <p>It also can be used in MicroPython.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#synchronous-programming","title":"Synchronous Programming","text":"<pre><code>pip install dweeter\n</code></pre>"},{"location":"#asynchronous-programming","title":"Asynchronous Programming","text":"<pre><code>pip install dweeter[aiohttp]\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#synchronous-programming_1","title":"Synchronous Programming","text":"Code <pre><code>import time\nfrom dweeter import Dweeter\n\ndwtr = Dweeter(\"MAILBOX_NAME\", \"KEY_TO_MAILBOX\")\n\nprint(dwtr.send_data({\"DATA_1\": \"VALUE_1\"}))\ntime.sleep(2)\nprint(dwtr.get_new_data())\ntime.sleep(2)\nprint(dwtr.send_data({\"DATA_2\": \"VALUE_2\"}))\ntime.sleep(2)\nprint(dwtr.get_new_data())\n</code></pre> Output <pre><code>{'thing': '42e6ae04e842cadca8a814fea06bcf6d', 'created': '2024-07-15T05:11:32.709Z', 'content': {'904b0c7d2cfe0dd2501e7f25101fb92457f58052e8526dafb38b883438896980': '4c03f62878dd6d9befdc92e00a2a1bd4906c9590838f7758062e37b99c05b696cb01b729f7c9faa6962726e5dc6a4b1ad522dd0dceb3870106a67ebaedf9868b87548e04347fbc721e152f03ac405fb1'}, 'transaction': 'c8f956a5-e516-4ad4-afa5-5035d4206179'}\n{'DATA_1': 'VALUE_1', 'remote_time': '2024-07-15T05:11:31.000Z', 'created_time': '2024-07-15T05:11:32.709Z'}\n{'thing': '42e6ae04e842cadca8a814fea06bcf6d', 'created': '2024-07-15T05:11:38.580Z', 'content': {'904b0c7d2cfe0dd2501e7f25101fb924cb74208c05dc802c752e5e2717f4c717': '10753b950ecdcbf5a9b7cd82f82c3bac7d5b522a175897e2db32457d6f373cbc2fe8f7ef551284de110e6b9abfa058404b8f9d4126e18d3c32e137e5902f298c722cf8261460613602484dae350cb8f6'}, 'transaction': '2dcec037-9b02-4dc2-a6c1-26cc0beb4e03'}\n{'DATA_2': 'VALUE_2', 'remote_time': '2024-07-15T05:11:37.000Z', 'created_time': '2024-07-15T05:11:38.580Z'}\n</code></pre>"},{"location":"#asynchronous-programming_1","title":"Asynchronous Programming","text":"Code <pre><code>import asyncio\nfrom dweeter import Dweeter\n\nasync def async_main():\n    dwtr = Dweeter(\"MAILBOX_NAME\", \"KEY_TO_MAILBOX\")\n\n    print(await dwtr.async_send_data({\"DATA_1\": \"VALUE_1\"}))\n    await asyncio.sleep(2)\n    print(await dwtr.async_get_new_data())\n    await asyncio.sleep(2)\n    print(await dwtr.async_send_data({\"DATA_2\": \"VALUE_2\"}))\n    await asyncio.sleep(2)\n    print(await dwtr.async_get_new_data())\n\nasyncio.run(async_main())\n</code></pre> Output <pre><code>{'thing': '42e6ae04e842cadca8a814fea06bcf6d', 'created': '2024-07-15T05:12:20.059Z', 'content': {'0d93e2a03ea4fea5741276e310398b65e6f55f0456d6d2bb74b01ffca22bf9ba': '4c03f62878dd6d9befdc92e00a2a1bd4906c9590838f7758062e37b99c05b696cb01b729f7c9faa6962726e5dc6a4b1a3b18b95d5e6552c4b61913acf2861b0e3a45a4113ac684bc5a08bf5a82d65816'}, 'transaction': 'e5b08537-2c14-4ce9-be72-5d804607ce26'}\n{'DATA_1': 'VALUE_1', 'remote_time': '2024-07-15T05:12:19.000Z', 'created_time': '2024-07-15T05:12:20.059Z'}\n{'thing': '42e6ae04e842cadca8a814fea06bcf6d', 'created': '2024-07-15T05:12:25.941Z', 'content': {'0d93e2a03ea4fea5741276e310398b6557ef5805e83d93aa199097fd01b51821': '10753b950ecdcbf5a9b7cd82f82c3bac7d5b522a175897e2db32457d6f373cbc2fe8f7ef551284de110e6b9abfa05840066efe7671423a88111a87a6a58076595fee9457ed0fa115dc463cf66c031017'}, 'transaction': 'b025efed-16ab-46ba-96f3-4df72ef5dcdf'}\n{'DATA_2': 'VALUE_2', 'remote_time': '2024-07-15T05:12:25.000Z', 'created_time': '2024-07-15T05:12:25.941Z'}\n</code></pre>"},{"location":"#test","title":"Test","text":"<pre><code>python -m pytest\n</code></pre>"},{"location":"#build-documentation","title":"Build documentation","text":"<pre><code>mkdocs build\n</code></pre>"},{"location":"#change","title":"Change","text":"<ul> <li>v0.3.0:<ul> <li><code>CryptoDweet</code> class is added.</li> <li>Asynchronous methods are added for asynchronous programming.</li> <li>Dweet content dictionary can be encoded with base64 to be more compact.</li> </ul> </li> </ul>"},{"location":"#on-messaging-security","title":"On messaging security","text":"<p>The free dweet service is public. By \"public\", it means:</p> <ul> <li>Every one on Internet can see what you are sending.</li> <li>Every one can send something for the same \"thing\" name to confuse you.</li> </ul> <p>The publicly exposed user information:</p> <ul> <li>The \"thing\" name, which you can think of as the unique virtual mailbox name.</li> <li>The keys of the \"content\" dictionary.</li> <li>The values of the \"content\" dictionary.</li> </ul> <p>The dweeter module wraps the contents as a single key-value pair. So there is only one key and one value in the \"content\" dictionary. And the \"thing\" name and the \"content\" dictionary are encrypted. So no one knows what they mean.</p> <p>Without knowing what the information means, potential attackers can still send something for the same \"thing\" name. Because the \"content\" dictionary is encrypted, the only way to do this is to capture a bunch of messages and send them randomly. The key and the value of the \"content\" dictionary both include the same time stamp. A mismatch of them will result in an error that is handled by dweeter. But a copy of the whole \"content\" dictionary could still be passed on to the receiver. This is often referred to as \"replay attack\".</p> <p>The decrypted user data dictionary includes 2 extra key-value pairs:</p> <ul> <li>\"created_time\", the timestamp from the dweet service.</li> <li>\"remote_time\", the timestamp from the sending device.</li> </ul> <p>You can compare these two timestamps to decide if a \"replay attack\" happened. On a micropython device, you can use <code>ntptime.settime()</code> to set the local time. Be aware of a normal gap between \"created_time\" and \"remote_time\". On a PC I observed 4 to 5 seconds difference. On a micropython device I observed 8 to 9 seconds difference. This time difference could vary from case to case.</p>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#dweeter_1","title":"dweeter","text":"<p> dweeter </p> <p> package dweeter</p> <p>Encrypted messaging through the free dweet service.</p> <ul> <li>Author: Quan Lin</li> <li>License: MIT</li> </ul> <p>Classes</p> <ul> <li> <p>DweeterError </p> </li> <li> <p>CryptoDweet \u2014 A class for the free dweet service with encryption.   </p> </li> <li> <p>Dweeter \u2014 A class for encrypted messaging through the free dweet service.   </p> </li> </ul>"},{"location":"api/#cryptodweet","title":"CryptoDweet","text":"<p> dweeter.dweeter.CryptoDweet </p> <p> class CryptoDweet(aes_cbc_key: bytes = b'aes_cbc_key', aes_cbc_iv: bytes = b'aes_cbc_iv', base_url: str = DEFAULT_BASE_URL, use_base64: bool = False)</p> <p>A class for the free dweet service with encryption.</p> <p>Initialization options:</p> <ul> <li><code>CryptoDweet()</code>: With default key and iv, not secure.</li> <li><code>CryptoDweet(b\"YOUR_KEY\")</code>: Only set key, with default iv.</li> <li><code>CryptoDweet(b\"YOUR_KEY\", b\"YOUR_IV\")</code>: Set both key and iv, strongest encryption.</li> </ul> <p>Parameters</p> <ul> <li> <p>aes_cbc_key    \u2014 The key of AES CBC mode.   </p> </li> <li> <p>aes_cbc_iv    \u2014 The IV of AES CBC mode.   </p> </li> <li> <p>base_url    \u2014 The base url of the dweet server.   </p> </li> <li> <p>use_base64    \u2014 Use base64 to make dweet content dictionary more compact.   </p> </li> </ul> <p>Methods</p> <ul> <li> <p>dweet_for \u2014 The \"dweet for\" API.   </p> </li> <li> <p>get_latest_dweet_for \u2014 The \"get latest dweet for\" API.   </p> </li> <li> <p>get_dweets_for \u2014 The \"get dweets for\" API.   </p> </li> <li> <p>async_dweet_for \u2014 The async \"dweet for\" API.   </p> </li> <li> <p>async_get_latest_dweet_for \u2014 The async \"get latest dweet for\" API.   </p> </li> <li> <p>async_get_dweets_for \u2014 The async \"get dweets for\" API.   </p> </li> </ul> <p> dweeter.dweeter.CryptoDweet.dweet_for </p> <p> method CryptoDweet.dweet_for(thing: str, content_dict: dict[str, str]) \u2192 dict</p> <p>The \"dweet for\" API.</p> <p>Parameters</p> <ul> <li> <p>thing :    str \u2014 The thing name.   </p> </li> <li> <p>content_dict :    dict[str, str] \u2014 The content dict.   </p> </li> </ul> <p>Returns</p> <ul> <li> <p>dict \u2014 The result dict of \"dweet for\" API.   </p> </li> </ul> <p> dweeter.dweeter.CryptoDweet.get_latest_dweet_for </p> <p> method CryptoDweet.get_latest_dweet_for(thing: str) \u2192 list</p> <p>The \"get latest dweet for\" API.</p> <p>Parameters</p> <ul> <li> <p>thing :    str \u2014 The thing name.   </p> </li> </ul> <p>Returns</p> <ul> <li> <p>list \u2014 The result list of dict of \"get latest dweet for\" API.   </p> </li> </ul> <p> dweeter.dweeter.CryptoDweet.get_dweets_for </p> <p> method CryptoDweet.get_dweets_for(thing: str) \u2192 list</p> <p>The \"get dweets for\" API.</p> <p>Parameters</p> <ul> <li> <p>thing :    str \u2014 The thing name.   </p> </li> </ul> <p>Returns</p> <ul> <li> <p>list \u2014 The result list of dict of \"get dweets for\" API.   </p> </li> </ul> <p> dweeter.dweeter.CryptoDweet.async_dweet_for </p> <p> method CryptoDweet.async_dweet_for(thing: str, content_dict: dict[str, str]) \u2192 dict</p> <p>The async \"dweet for\" API.</p> <p>The arguments have the same meaning as in <code>dweet_for</code>.</p> <p> dweeter.dweeter.CryptoDweet.async_get_latest_dweet_for </p> <p> method CryptoDweet.async_get_latest_dweet_for(thing: str) \u2192 list</p> <p>The async \"get latest dweet for\" API.</p> <p>The arguments have the same meaning as in <code>get_latest_dweet_for</code>.</p> <p> dweeter.dweeter.CryptoDweet.async_get_dweets_for </p> <p> method CryptoDweet.async_get_dweets_for(thing: str) \u2192 list</p> <p>The async \"get dweets for\" API.</p> <p>The arguments have the same meaning as in <code>get_dweets_for</code>.</p>"},{"location":"api/#dweeter_2","title":"Dweeter","text":"<p> dweeter.dweeter.Dweeter </p> <p> class Dweeter(mailbox: str = 'default_mailbox', key: str = 'default_key', debug: bool = False, base_url: str = DEFAULT_BASE_URL, use_base64: bool = False)</p> <p>A class for encrypted messaging through the free dweet service.</p> <p>Parameters</p> <ul> <li> <p>mailbox    \u2014 A virtual mailbox name.   </p> </li> <li> <p>key    \u2014 The key to the virtual mailbox.   </p> </li> <li> <p>debug    \u2014 If it is <code>True</code>, exceptions will be printed. Otherwise exceptions will be swallowed silently.   </p> </li> <li> <p>base_url    \u2014 The base url of the dweet server.   </p> </li> <li> <p>use_base64    \u2014 Use base64 to make dweet content dictionary more compact.   </p> </li> </ul> <p>Notes</p> <p>With the same <code>mailbox</code>, when using a different <code>key</code> or different <code>use_base64</code> settings, it actually creates a different thing name in dweet service.</p> <p>Methods</p> <ul> <li> <p>send_data \u2014 Send <code>data_dict</code> to the mailbox.   </p> </li> <li> <p>get_new_data \u2014 Receive the latest and new <code>data_dict</code> from the mailbox.   </p> </li> <li> <p>async_send_data \u2014 Send <code>data_dict</code> to the mailbox asynchronously.   </p> </li> <li> <p>async_get_new_data \u2014 Receive the latest and new <code>data_dict</code> from the mailbox asynchronously.   </p> </li> </ul> <p> dweeter.dweeter.Dweeter.send_data </p> <p> method Dweeter.send_data(data_dict: dict) \u2192 dict</p> <p>Send <code>data_dict</code> to the mailbox.</p> <p>Parameters</p> <ul> <li> <p>data_dict :    dict \u2014 The data dictionary to send to the mailbox. This dictionary must be json compatible. There are 2 keys reserved for data_dict. One is <code>created_time</code>, the dweet service time. The other is <code>remote_time</code>, the local time of the remote device.   </p> </li> </ul> <p>Returns</p> <ul> <li> <p>dict \u2014 The dweet transaction dict returned from dweet service. It should include the keys of <code>thing</code>, <code>content</code>, <code>created</code> and <code>transaction</code>.   </p> </li> </ul> <p>Raises</p> <ul> <li> <p>DweeterError </p> </li> </ul> <p> dweeter.dweeter.Dweeter.get_new_data </p> <p> method Dweeter.get_new_data() \u2192 dict</p> <p>Receive the latest and new <code>data_dict</code> from the mailbox.</p> <p>Returns</p> <ul> <li> <p>dict \u2014 The latest and new data dictionary from the mailbox. None will be returned if the latest <code>data_dict</code> is old.   </p> </li> </ul> <p>Raises</p> <ul> <li> <p>DweeterError </p> </li> </ul> <p> dweeter.dweeter.Dweeter.async_send_data </p> <p> method Dweeter.async_send_data(data_dict: dict) \u2192 dict</p> <p>Send <code>data_dict</code> to the mailbox asynchronously.</p> <p>The arguments have the same meaning as in <code>send_data</code>.</p> <p>Raises</p> <ul> <li> <p>DweeterError </p> </li> </ul> <p> dweeter.dweeter.Dweeter.async_get_new_data </p> <p> method Dweeter.async_get_new_data() \u2192 dict</p> <p>Receive the latest and new <code>data_dict</code> from the mailbox asynchronously.</p> <p>The arguments have the same meaning as in <code>get_new_data</code>.</p> <p>Raises</p> <ul> <li> <p>DweeterError </p> </li> </ul>"}]}